<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


  <link href="../files/css/shCore.css" rel="stylesheet" type="text/css" />
  <link href="../files/css/shThemeDefault.css" rel="stylesheet" type="text/css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Verification of ROS-based Systems: Guidelines for Developers and QA Teams</title>
  <meta name="description" content="">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="generator" content="Hugo 0.57.2">
  <meta name="robots" content="index,follow">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="Verification of ROS-based Systems">
  <meta property="og:description" content="">
  <meta property="og:type" content="website">
  <meta property="og:url" content="-">
  <link rel="stylesheet" href="../files/styles.css">
  <link rel="stylesheet" href="../files/css">
  <link rel="stylesheet" href="../files/font-awesome.min.css"
    integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">




  <link href="-index.xml" rel="alternate" type="application/rss+xml">



  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

  <script id="MathJax-script" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_HTML"></script>

  <script id="MathJax-script" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_HTML">

      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          autoload: {
            color: [],
            colorv2: ['color']
          },
          displayMath: [['$$', '$$']],
          processEscapes: true,
          processEnvironments: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
          TeX: {
            equationNumbers: { autoNumber: "AMS" },
            extensions: ["AMSmath.js", "AMSsymbols.js"], packages: { '[+]': ['noerrors'] }
          }
        }
      });
      MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(), i;
        for (i = 0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });

      MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }

      });


      MathJax.Hub.Register.MessageHook("Math Processing Error", function (message) {
        //  do something with the error.  message[2] is the Error object that records the problem.
      });


    </script>


  <style>
    code.has-jax {
      font: inherit;
      font-size: 100%;
      background: inherit;
      border: inherit;
      color: #515151;
    }


    .patternformulae {
      display: block;
      margin-left: auto;
      margin-right: auto;
      padding: 70px;
      width: 90%;
    }
  </style>
  <style id="fit-vids-style">
    .fluid-width-video-wrapper {
      width: 100%;
      position: relative;
      padding: 0;
    }

    .fluid-width-video-wrapper iframe,
    .fluid-width-video-wrapper object,
    .fluid-width-video-wrapper embed {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
  <style type="text/css">
    .MathJax_Hover_Frame {
      border-radius: .25em;
      -webkit-border-radius: .25em;
      -moz-border-radius: .25em;
      -khtml-border-radius: .25em;
      box-shadow: 0px 0px 15px #83A;
      -webkit-box-shadow: 0px 0px 15px #83A;
      -moz-box-shadow: 0px 0px 15px #83A;
      -khtml-box-shadow: 0px 0px 15px #83A;
      border: 1px solid #A6D ! important;
      display: inline-block;
      position: absolute
    }
  </style>
</head>

<body>
  <div id="MathJax_Message" style="display: none;"></div>

  <script type="application/javascript">
    var doNotTrack = false;
    if (!doNotTrack) {
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
          m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
      ga('create', 'UA-33213501-2', 'auto');

      ga('send', 'pageview');
    }
  </script>


  <header class="site-header">
    <div class="container">
      <div class="titlespan">
        <div class="perspective-text">
          <div class="perspective-line">
            <p class="paragraph"></p>
            <p class="paragraph">Verification</p>
          </div>
          <div class="perspective-line">
            <p class="paragraph">Verification</p>
            <p class="paragraph">of</p>
          </div>
          <div class="perspective-line">
            <p class="paragraph">of</p>
            <p class="paragraph">ROS-based</p>
          </div>
          <div class="perspective-line">
            <p class="paragraph">ROS-based</p>
            <p class="paragraph">Systems</p>
          </div>
          <div class="perspective-line">
            <p class="paragraph">Systems</p>
            <p></p>
          </div>
        </div>
      </div>
    </div>

    <ul class="site-nav">

      <li class="site-nav-item">
          <a title="Guideline Catalog" href="https://ros-rvft.github.io/index">Guideline
              Catalog</a>
      </li>

      <li class="site-nav-item">
          <a title="Replication package"
              href="https://ros-rvft.github.io/replication">Replication Package</a>
      </li>

      <li class="site-nav-item">
          <a title="Evaluation" href="https://ros-rvft.github.io/evaluation">Evaluation</a>
      </li>

      <li class="site-nav-item">
          <a title="Contribute" href="https://ros-rvft.github.io/contribute">Contribute</a>
      </li>

      <li class="site-nav-item">
          <a title="Authors" href="https://ros-rvft.github.io/authors">Authors</a>
      </li>

      <li class="site-nav-item">
          <a title="Research" href="https://ros-rvft.github.io/research">Cite Us!</a>
      </li>

  </ul>
    </div>



    <!-- ---------------------------------- CONTENT ---------------------------------- -->

  </header>
  <!-- ---------------------------------- GUIDELINE HEADER ---------------------------------- -->
  <div class="container">
    <article class="post-container">
      <header class="post-header">
        <h1 class="post-title">I2. Provide an API for logging and filtering</h1>
      </header>

      <div class="post-content clearfix">


        <h2 id="intent">Context (WHEN)</h2>

        <blockquote>
          <p>Dynamically gathering information is a fundamental step for gaining confidence in ROS-based systems. Logging (and playback) is, in fact, one of the most used techniques for testing ROS-based systems [1]. Often named monitoring [2], or logging [3], the process of recording textual or numerical information about events of interest may be a valuable input to the testing team. With such data in hand, the testing team will process the data and transform it into useful information to challenge their hypotheses about how the system should work. </p>
        </blockquote>



        <h2 id="relationships"> Reason (WHY)</h2>
        <p>Logging important events
          depends on instrumenting the code (with ‘hooks’) that
          enables the information retrieval activity. It is unrealistic
          to assume that the testing team will have access to the source
          code or that the testing team knows what events to log or
          how to do so.</p>

        <h2 id="occurences">Suggestion (WHAT)</h2>

        <p>The development team
          should provide an API for logging and filtering data to
          enable access to valuable runtime data which should be used
          for both runtime verification and field-based testing. The
          standard approach to logging and filtering is rosbag (wiki:
          rosbag). Though, in addition, AWS CloudWatch (git: aws-
          robotics/cloudwatchlogs-ros2) collects data from the rosout
          topic and provides a filter for eliminating noise from the
          logged events. Another example is the Robotic Black Box (git:
          ropod-project/black-box) which allows for listening to data
          traffic from distinct sources and logging the messages using
          MongoDB.</p>


        <h2>Process (HOW)</h2>

        <p>We divide, according to Falcone et al. [2], techniques for gathering information in two: inline, and outline. Inline logging and filtering stand for techniques that ask for actually inserting snippets of code in the system under scrutiny as a means to provide an API for logging, e.g., [4]. Outline logging and filtering stands for techniques that enable an external means to gather and filter information that does not require changing the source code, e.g., [5, 6, 7]. Developers may choose one or another given their domain of application. </p>



        <h2>Exemplars</h2>
        <h4 style="text-indent: 25px;">Inline logging and filtering</h4>

        <p>
          ROS, by standard, contains a system-wide string logging mechanism, namely ROS logging (<a href="http://wiki.ros/logging">(logging)</a>). ROS logging works with a set of macros defined for instrumenting the nodes with information hooks. In the background, the macros send messages with the information to be 1 logged through a standard topic called rosout. On the other side of the topic, an extra node, within the roscore package, persists the data in a textual format <a href="https://github.com/ros/ros_comm/blob/noetic-devel/clients/rospy/src/rospy/impl/rosout.py">(rosout)</a>. Developers can use the macros to log information that might be used for testing in a later stage, given the application-specific requirements. For instance, the Amazon AWS service for robotics provides AWS CloudWatch Logs (aws-robotics/cloudwatchlogs-ros2 ) interfaces directly with rosout to monitor applications using the standard ROS logging interface. In addition, the standard library provides logging macros with embedded filtering capabilities, which enables eliminating noise from the logged events and can render a useful tool for testers. ROS Rescue [4] is another example of inline logging. The tool aims at solving the problem of ROSMaster as a single point of failure. The authors approach check-pointing and restoring state by logging changes in the metadata stored in the master node. Such metadata contains URIs from various nodes, port numbers, published or subscribed topics, services, and parameters from the parameter server. Kaveti P. et al. create an API for the ROS master node (master api.py ) using the official logging library from Python1 to persist metadata in YAML format. Their technique opens space for further inspection of ROS applications without access to the source code. 
        </p>

        <p>
          For instance, the Amazon AWS service for robotics provides AWS
          CloudWatch Logs (aws-robotics/cloudwatchlogs-ros2) <a href="https://github.com/aws-robotics/cloudwatchlogs-ros2">(cloudwatchlogs-ros2)</a>
          interfaces directly with rosout to monitor applications using
          the standard ROS logging interface. In addition, the standard
          library provides logging macros with embedded filtering
          capabilities, which enables eliminating noise from the logged
          events and can render a useful tool for testers. ROS Res-
          cue is another example of inline logging. The tool aims
          at solving the problem of ROSMaster as a single point of
          failure. The authors approach check-pointing and restoring
          state by logging changes in the metadata stored in the master
          node. Such metadata contains URIs from various nodes,
          port numbers, published or subscribed topics, services, and
          parameters from the parameter server. Kaveti P. et al. create
          an API for the ROS master node (master api.py) <a href="https://github.com/PushyamiKaveti/fault-tolerant-ros-master/blob/master/src/ros_comm/rosmaster/src/rosmaster/master_api.py">(master-api)</a> using
          the official logging library from Python14 to persist metadata
          in YAML format. Their technique opens space for further
          inspection of ROS applications without access to the source
          code
        </p>

        <h4 style="text-indent: 25px;">Outline logging and filtering</h4>

        <p>
          ROSMonitoring <a href="https://github.com/autonomy-and-verification-uol/ROSMonitoring/blob/master/generator/online_config.yaml">(ROSMonitoring)</a> [5] employs monitors to persist events in textual format. The monitors contain filtering capabilities to eliminate entries that are inconsistent with the specification (requires an oracle). In this context, the launch files to configure ROSMonitoring can be seen as an API for logging and filtering (ROSMonitoring/../online config.yaml ). Monitors in ROSMonitoring are nodes, thus, the API is a set of known topics and message formats. The tester, in that case, only needs to specify what topics ROSMonitoring will listen to and the type of message to be recorded. The logging and filtering happen within a separate service. On a similar stance, and inspired by aircraft black box (and software black box [6]), Mitrevski, et al. [7] proposes the concept of Robotic Black Box (ropod-project/black-box). The black box operates as an isolated component responsible for listening to data traffic from distinct sources and logging in an easily retrievable medium. Similarly to ROSMonitoring, Mitrevski’s black box approach to logging (ropod-project/black-box/../logger main.*) inspects topics and message types that are configured in advance. Different from ROSMonitoring, Robotic Black Box offers logging not only in textual format but also in a MongoDB database, which is essentially useful for data processing, filtering, and retrieval. Robotic Black Box stands out when it comes to its filtering and retrieval capabilities. The approach builds a customized query interface over the MongoDB database using names of collections, timestamps and metadata to filter the results (black box tools/db utils.py). 
        </p>

        <p>
          On a similar stance,
          and inspired by aircraft black box (and software black
          box), Mitrevski, et al. proposes the concept of
          Robotic Black Box <a href="https://github.com/ropod-project/black-box">(ropod-project/black-box)</a>. The black
          box operates as an isolated component responsible for
          listening to data traffic from distinct sources and logging
          in an easily retrievable medium. Similarly to ROSMoni-
          toring, Mitrevski’s black box approach to logging <a href="https://github.com/ropod-project/black-box/blob/master/pybb/logger_main.py">(ropod-
            project/black-box/../logger main.*)</a>  inspects topics and
          message types that are configured in advance. Different from
          ROSMonitoring, Robotic Black Box offers logging not only
          in textual format but also in a MongoDB database, which is
          essentially useful for data processing, filtering, and retrieval.
          Robotic Black Box stands out when it comes to its filtering
          and retrieval capabilities. The approach builds a customized
          query interface over the MongoDB database using names
          of collections, timestamps and metadata to filter the results
         <a href="https://github.com/ropod-project/black-box-tools/blob/master/black_box_tools/db_utils.py"> (black box tools/db utils.py)</a>
        </p>

        <p class="strengths" style="text-indent: 25px;">Strengths:</p>
        <p> 
          An API for retrieval and filtering
          facilitates access to valuable information resulting in effortless observability of inner states and events</p>


        <p class="weaknesses" style="text-indent: 25px;">Weaknesses:</p>
        <p>
          Overuse of logging may result
          in performance issues. Incorrectly implemented logging and
          filtering capabilities may lead to noise in the data, impacting
          the reliability of the tests. Finally, insufficient logging may
          result in an incomplete assessment of the system behavior
          and might generate false positives
        </p>



          <!-- ---------------------------------- GUIDELINE CONTENT END ---------------------------------- -->


          <p class="" style="text-indent: 25px;"> References </p> 
          <blockquote>
  
            <p> [1] A. Afzal, C. Le Goues et al., “A study on challenges of testing robotic systems,” in 2020 IEEE 13th International Conference on Software Testing, Validation and Verification (ICST). IEEE, 2020, pp. 96–107. </p>
            <p>[2] Y. Falcone, S. Krsti´c et al., “A taxonomy for classifying runtime verification tools,” International Journal on Software Tools for Technology Transfer, vol. 23, no. 2, pp. 255–284, 2021. </p>
            <p>[3] A. Bertolino, P. Braione et al., “A survey of field-based testing techniques,” ACM Computing Surveys (CSUR), vol. 54, no. 5, pp. 1–39, 2021. </p>
            <p>[4] P. Kaveti and H. Singh, “Ros rescue: fault tolerance system for robot operating system,” Robot Operating System (ROS) The Complete Reference (Volume 5), pp. 381–397, 2021. </p>
            <p>[5] A. Ferrando, R. C. Cardoso et al., “Rosmonitoring: a runtime verification framework for ros,” in Annual Conference Towards Autonomous Robotic Systems. Springer, 2020, pp. 387–399. </p>
            <p>[6] S. Elbaum and J. C. Munson, “Software black box: an alternative mechanism for failure analysis,” in Proceedings 11th International Symposium on Software Reliability Engineering. ISSRE 2000. IEEE, 2000, pp. 365–376. </p>
            <p>[7] A. Mitrevski, S. Thoduka et al., “Deploying robots in everyday environments: Towards dependable and practical robotic systems,” arXiv preprint arXiv:2206.12719, 2022. </p>
          <blockquote>

        </div>

      </div>

      <footer class="post-footer clearfix">


        <div class="share">




        </div>

  </div>
  <footer class="footer">
    <div class="container">
      <div class="site-title-wrapper">
        <h1 class="site-title">
          <a title="VERIFICATION OF ROS-BASED SYSTEMS" href="-">VERIFICATION OF ROS-BASED SYSTEMS</a>
        </h1>

      </div>

      <p class="footer-copyright">
        <span>Ricardo Caldas, Juan Antonio Pinera Garcia, Matei Schiopu,
          Patrizio Pelliccione, Genaina Rodrigues, and Thorsten Berger © 2024 </span>
      </p>
      <p class="footer-copyright">


      </p>
    </div>
  </footer>

  <script src="../files/jquery-1.11.3.min.js.download"></script>
  <script src="../files/jquery.fitvids.js.download"></script>
  <script src="../files/highlight.min.js.download"></script>
  <script src="../files/scripts.js.download"></script>


</body>

</html>